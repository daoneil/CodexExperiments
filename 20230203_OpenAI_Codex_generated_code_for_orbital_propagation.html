
<html>
    <head>
	<title>Orbital Propagator</title>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/5.0.0/satellite.min.js"></script>
        <script>
        document.addEventListener("DOMContentLoaded", function() {

var canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
document.body.appendChild(canvas);
var engine = new BABYLON.Engine(canvas, true);
var scene = new BABYLON.Scene(engine);
var camera = new BABYLON.ArcRotateCamera("Camera", 0, Math.Pi, 30, new BABYLON.Vector3(0, 0, 0), scene);
camera.setPosition(new BABYLON.Vector3(0, -30, 0));
camera.attachControl(canvas, true);
// var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, -3, 0), scene);
var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(0, 30, 0), scene);
var sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 14, scene);
//sphere.position.y = 1;

var material = new BABYLON.StandardMaterial("material1", scene);
var earthMapURL = "https://upload.wikimedia.org/wikipedia/commons/0/04/Solarsystemscope_texture_8k_earth_daymap.jpg";

material.diffuseTexture = new BABYLON.Texture(earthMapURL, scene);
material.diffuseTexture.vScale = -1;
material.diffuseTexture.uScale = -1;
sphere.material = material;
// Data from the Two Line Elements (TLE) is oriented with the Z-axis up.
// BabylonJS has the Y-axis up. To display the Earth in the correct orientation, the camera should look down
// the Y-axis, the Earth should be rotated 90 degrees on the X-axis, the tilted 23 degrees on the Y-axis.
sphere.rotation.x = 1.57;           
sphere.rotation.y = -0.401426; 

var twoLineElements = [];
var cartesianCoordinates = [];
var timeSinceTLEepochMinutes = 0;
var secCount = 0;  // interval loop counter
var numSec = 5;   

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404; so check the status
      if (req.status == 200) {
	     twoLineElements = req.responseText.split('\n');
		 	 
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // Make the request
    req.send();
  });
}

function UpdateCoordinates(timeSinceTLEepochMinutes) {

  var j = 0;  // Cartesian Coordinates array index.
  for (var i = 0; i < twoLineElements.length; i += 2) {
    var tle_1 = twoLineElements[i];
    var tle_2 = twoLineElements[i + 1];
	
	if (tle_1 || tle_2) {
    var satrec = satellite.twoline2satrec(tle_1, tle_2);
	
	var positionAndVelocity = satellite.sgp4(satrec, timeSinceTLEepochMinutes);
	
	// These are the base results from which all other coordinates are derived.
    var positionEci = positionAndVelocity.position,
    velocityEci = positionAndVelocity.velocity;
	
    var geodeticCoordinates = satellite.eciToGeodetic(positionAndVelocity.position, satellite.gstime(timeSinceTLEepochMinutes));
    console.log("lat: " + geodeticCoordinates.latitude + "  lon: " + geodeticCoordinates.longitude);

	var sr = 8;
    var cartesianCoordinate = new BABYLON.Vector3(sr* Math.cos(geodeticCoordinates.latitude) * Math.cos(geodeticCoordinates.longitude),
	                                              sr * Math.cos(geodeticCoordinates.latitude) * Math.sin(geodeticCoordinates.longitude),
												  sr * Math.sin(geodeticCoordinates.latitude));	
												  
 // console.log(cartesianCoordinate);
    cartesianCoordinates[j] = cartesianCoordinate;
	j = j + 1;
	}
  }
}

get('https://celestrak.org/NORAD/elements/gp.php?GROUP=iridium-33-debris&FORMAT=2le').then(function(response) {
  console.log("Success!", response);
  
    let iNumBoxes = 255;
    var smallBoxes = [];
    for (var i = 0; i < iNumBoxes; i++) {
       var box = BABYLON.MeshBuilder.CreateBox('box' + i, {size: 0.13}, scene);
       var material = new BABYLON.StandardMaterial('material' + i, scene);
       material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
       box.material = material;
       smallBoxes.push(box);
    }

scene.registerBeforeRender(function() {
 // if(sphere){
    sphere.rotate(BABYLON.Axis.Y, -0.0005, BABYLON.Space.LOCAL);
 // }
});

   // Establish the render loop for updating the scene.
     engine.runRenderLoop(function () {
	   
 	    if (twoLineElements.length > 0) {
           UpdateCoordinates(timeSinceTLEepochMinutes); 
		   
		   if (cartesianCoordinates.length > 0) {
           for (var i = 0; i < smallBoxes.length; i++) {
               smallBoxes[i].position = cartesianCoordinates[i];
            }
           timeSinceTLEepochMinutes += 0.0005;
		   
	       scene.render();	   
           }
         }
 //   scene.render();
   });
  
}, function(error) {
  console.error("Failed!", error);
})


});
        </script>
    </head>
    <body style="margin: 0;">
        <div style="background-color: black; position: fixed; bottom: 0; width: 100%; height: 20px; padding: 20px; opacity: .85; z-index: 1000;">
            <svg id="Layer_1" data-name="Layer 1" height="40px" width="40px" style="top: -8px;
            position: relative;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 800"><defs><style>.cls-1{fill:#fff;}</style></defs><title>openai-symbol-flat-white</title><path class="cls-1" d="M617.24,354a126.36,126.36,0,0,0-10.86-103.79,127.8,127.8,0,0,0-137.65-61.32,126.36,126.36,0,0,0-95.31-42.49A127.81,127.81,0,0,0,251.5,234.89,126.4,126.4,0,0,0,167,296.19a127.82,127.82,0,0,0,15.72,149.86,126.36,126.36,0,0,0,10.86,103.79,127.81,127.81,0,0,0,137.65,61.32,126.36,126.36,0,0,0,95.31,42.49A127.81,127.81,0,0,0,548.5,565.11,126.4,126.4,0,0,0,633,503.81,127.82,127.82,0,0,0,617.24,354ZM426.58,620.49a94.79,94.79,0,0,1-60.85-22c.77-.42,2.12-1.16,3-1.7l101-58.34a16.42,16.42,0,0,0,8.3-14.37V381.69l42.69,24.65a1.52,1.52,0,0,1,.83,1.17V525.43A95.18,95.18,0,0,1,426.58,620.49ZM222.34,533.26A94.74,94.74,0,0,1,211,469.56c.75.45,2.06,1.25,3,1.79l101,58.34a16.44,16.44,0,0,0,16.59,0l123.31-71.2v49.3a1.53,1.53,0,0,1-.61,1.31L352.19,568.05A95.16,95.16,0,0,1,222.34,533.26ZM195.77,312.77a94.71,94.71,0,0,1,49.48-41.68c0,.87-.05,2.41-.05,3.48V391.25a16.41,16.41,0,0,0,8.29,14.36L376.8,476.8l-42.69,24.65a1.53,1.53,0,0,1-1.44.13l-102.11-59A95.16,95.16,0,0,1,195.77,312.77Zm350.74,81.62L423.2,323.19l42.69-24.64a1.53,1.53,0,0,1,1.44-.13l102.11,58.95a95.08,95.08,0,0,1-14.69,171.55c0-.88,0-2.42,0-3.49V408.75A16.4,16.4,0,0,0,546.51,394.39ZM589,330.44c-.75-.46-2.06-1.25-3-1.79L485,270.31a16.46,16.46,0,0,0-16.59,0l-123.31,71.2v-49.3a1.53,1.53,0,0,1,.61-1.31L447.81,232A95.07,95.07,0,0,1,589,330.44ZM321.89,418.31l-42.7-24.65a1.52,1.52,0,0,1-.83-1.17V274.57a95.07,95.07,0,0,1,155.9-73c-.77.42-2.11,1.16-3,1.7l-101,58.34a16.41,16.41,0,0,0-8.3,14.36Zm23.19-50L400,336.59l54.92,31.7v63.42L400,463.41l-54.92-31.7Z"/></svg>
            <div style="display: inline-block; color: white; vertical-align: top; margin-top: 4px; font-family: Helvetica, sans-serif;">
                Some of the code was generated by <a style="color: white; text-decoration: none; font-weight: bold;" href="https://openai.com/blog/openai-codex/">OpenAI Codex</a>
            </div>
        </div>
    </body>
</html>
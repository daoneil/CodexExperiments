<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbulb Raymarching</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
<!--
The prompt provided to Claude.ai that generated this code:
Please write shader code, embedded in HTML, that implements a Mandelbulb SDF and a ray marching renderer. 
Include functions for antialiasing and coloring based on orbit traps.
-->
<canvas id="glCanvas"></canvas>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 aVertexPosition;
    void main() {
        gl_Position = aVertexPosition;
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 uResolution;
    uniform float uTime;

    #define MAX_STEPS 100
    #define MAX_DIST 100.0
    #define SURF_DIST 0.001
    #define PI 3.14159265359

    vec3 rotate(vec3 p, vec3 euler) {
        vec3 s = sin(euler), c = cos(euler);
        mat3 rx = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);
        mat3 ry = mat3(c.y, 0, s.y, 0, 1, 0, -s.y, 0, c.y);
        mat3 rz = mat3(c.z, -s.z, 0, s.z, c.z, 0, 0, 0, 1);
        return rz * ry * rx * p;
    }

    float mandelbulbSDF(vec3 pos) {
        vec3 z = pos;
        float dr = 1.0;
        float r = 0.0;
        float power = 8.0 + sin(uTime * 0.1) * 2.0;
        
        for (int i = 0; i < 15; i++) {
            r = length(z);
            if (r > 2.0) break;
            
            float theta = acos(z.z / r);
            float phi = atan(z.y, z.x);
            dr = pow(r, power - 1.0) * power * dr + 1.0;
            
            float zr = pow(r, power);
            theta = theta * power;
            phi = phi * power;
            
            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
            z += pos;
        }
        return 0.5 * log(r) * r / dr;
    }

    vec2 rayMarch(vec3 ro, vec3 rd) {
        float dO = 0.0;
        float minDist = 1e10;
        
        for(int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * dO;
            float dS = mandelbulbSDF(p);
            minDist = min(minDist, dS);
            dO += dS;
            if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;
        }
        
        return vec2(dO, minDist);
    }

    vec3 getNormal(vec3 p) {
        float d = mandelbulbSDF(p);
        vec2 e = vec2(.001, 0);
        vec3 n = d - vec3(
            mandelbulbSDF(p - e.xyy),
            mandelbulbSDF(p - e.yxy),
            mandelbulbSDF(p - e.yyx));
        return normalize(n);
    }

    vec3 getRayDirection(vec2 uv, vec3 p, vec3 l, float z) {
        vec3 f = normalize(l - p),
             r = normalize(cross(vec3(0, 1, 0), f)),
             u = cross(f, r),
             c = f * z,
             i = c + uv.x * r + uv.y * u,
             d = normalize(i);
        return d;
    }

    vec3 colorize(float minDist, vec3 p) {
        vec3 col = vec3(0.0);
        col += vec3(0.8, 0.1, 0.1) * exp(-minDist * 5.0);
        col += vec3(0.1, 0.8, 0.1) * exp(-minDist * 15.0);
        col += vec3(0.1, 0.1, 0.8) * exp(-minDist * 30.0);
        return col;
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution.xy) / uResolution.y;
        vec3 ro = vec3(3.0 * sin(uTime * 0.1), 2.0, 3.0 * cos(uTime * 0.1));
        vec3 rd = getRayDirection(uv, ro, vec3(0, 0, 0), 1.0);
        
        vec3 col = vec3(0);
        
        // Antialiasing
        const int AA = 2;
        for (int m = 0; m < AA; m++) {
            for (int n = 0; n < AA; n++) {
                vec2 offset = vec2(float(m), float(n)) / float(AA) - 0.5;
                vec2 uv2 = (gl_FragCoord.xy + offset - 0.5 * uResolution.xy) / uResolution.y;
                rd = getRayDirection(uv2, ro, vec3(0, 0, 0), 1.0);
                
                vec2 rm = rayMarch(ro, rd);
                float d = rm.x;
                float minDist = rm.y;
                
                if (d < MAX_DIST) {
                    vec3 p = ro + rd * d;
                    vec3 n = getNormal(p);
                    vec3 orbCol = colorize(minDist, p);
                    
                    // Basic lighting
                    vec3 lightDir = normalize(vec3(1, 1, 1));
                    float diff = max(dot(n, lightDir), 0.0);
                    vec3 diffuse = diff * vec3(1.0);
                    
                    col += orbCol * diffuse;
                } else {
                    col += vec3(0.05); // background color
                }
            }
        }
        col /= float(AA * AA);
        
        // Gamma correction
        col = pow(col, vec3(0.4545));
        
        gl_FragColor = vec4(col, 1.0);
    }
</script>
<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
        alert('Unable to initialize WebGL. Your browser or machine may not support it.');
    }

    const vertexShaderSource = document.getElementById('vertexShader').text;
    const fragmentShaderSource = document.getElementById('fragmentShader').text;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
    }

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
        -1.0,  1.0,
         1.0,  1.0,
        -1.0, -1.0,
         1.0, -1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const positionAttributeLocation = gl.getAttribLocation(program, 'aVertexPosition');
    const resolutionUniformLocation = gl.getUniformLocation(program, 'uResolution');
    const timeUniformLocation = gl.getUniformLocation(program, 'uTime');

    function resizeCanvasToDisplaySize(canvas) {
        const displayWidth  = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
        }
    }

    function render(time) {
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform1f(timeUniformLocation, time * 0.001);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>